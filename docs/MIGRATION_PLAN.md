# План миграции LifeMart Safety к мультичатовой архитектуре

Документ описывает, как перевести текущий бот модерации LifeMart Safety на поддержку нескольких чатов/каналов. Включены техническая реализация, анализ параметров конфигурации и перечень рисков.

---

## 1. Исходное состояние проекта

- Бот обслуживает один основной чат LifeMart, ключевые идентификаторы (чат, whitelist) заданы напрямую в `.env`.
- Политика модерации (`PolicyEngine`) и хранение артефактов (TF-IDF, мета-классификатор, датасет) едины для всех событий.
- Очереди модерации, логика хранения и карточки в Telegram не разделяют контекст по чатам.
- Runtime-настройки (`config/runtime.py`) рассчитаны на глобальные пороги, без привязки к отдельным сообществам.

---

## 2. Цели миграции

1. Поддержать независимую модерацию нескольких чатов LifeMart (городские сообщества, тематические каналы и т.п.).
2. Сохранять общую кодовую базу и набор ML-артефактов, но учитывать чат-специфичные параметры (пороги, белые списки, режимы).
3. Обеспечить минимальные изменения в рабочих процессах модераторов: карточки и кнопки остаются знакомыми, но содержат явную пометку чата.
4. Подготовить окружение для последующего масштабирования (добавление новых чатов через конфигурацию без релиза кода).

---

## 3. Техническая реализация

### 3.1 Архитектурные изменения
- **Абстракция контекста чата.** Ввести сущность `ChatContext` или аналогичный словарь, содержащий настройки конкретного чата: ID, режим модерации, пороги, whitelist, шаблоны сообщений.
- **Менеджер конфигураций.** Создать модуль (например, `services/chat_config.py`), который загружает конфигурацию из `config/chat_config.yaml` или из расширенных переменных окружения и предоставляет API: `get_chat_config(chat_id)`.
- **Обновление PolicyEngine.** Интерфейс `PolicyEngine` должен принимать конфигурацию чата при принятии решения: `PolicyEngine.apply(analysis, chat_config)`.
- **Хранение данных.** В таблицах/файлах для событий модерации добавить поле `chat_id`. Для существующих CSV — миграция с добавлением столбца и дефолтным значением текущего чата.
- **Фильтры.** Keyword/TF-IDF/Embedding могут оставаться общими. При необходимости реализовать переопределение словарей на уровне `ChatContext`.
- **Команды модераторов.** `/setpolicy`, `/setthreshold`, `/setdownweight` принимают дополнительный параметр — целевой чат. Без параметра команда применяется к чату пришедшего события.
- **UI карточек.** Визуально отображать чат (`<b>Чат:</b> ...`) и добавлять ссылку для быстрого перехода.

### 3.2 Конфигурация конфигураций
- Поддерживать общий конфигурационный файл `config/chat_config.yaml` (или JSON), где описываются чаты в виде:
  ```yaml
  chats:
    - id: -100111222333
      slug: moscow
      title: LifeMart Moscow
      policy_mode: semi-auto
      thresholds:
        notify: 0.65
        delete: 0.85
        kick: 0.95
      whitelist: [11111111, 22222222]
      announce_blocks: false
  ```
- Файл должен подхватываться на старте бота и кешироваться, изменения допускаются через рестарт или команду `/reload_config`.
- Для конфиденциальных значений (токены, API-ключи) продолжать использовать `.env`.

### 3.3 Изменения в storage
- Интерфейсы `storage/interfaces.py` расширить полем `chat_id`.
- Миграция существующих данных: добавить поле в текущие записи, проставить значение известного чата, обновить индексы (если БД).

### 3.4 Тестирование
- Юнит-тесты на `PolicyEngine` и `ChatConfigManager` с несколькими чатами.
- Интеграционные проверки: последовательность событий из разных чатов, отправка карточек, изменение порогов.
- Тестовые сценарии для `/setpolicy` и `/status` с указанием чата.

---

## 4. Возможные проблемы и риски

- **Конфликты конфигураций.** Ошибки в `chat_config.yaml` (дублирующиеся ID, некорректные пороги); необходимо валидация при загрузке.
- **Нагрузка на модераторов.** Увеличенное число карточек и риски перепутать целевой чат; требуется чёткая визуальная идентификация.
- **Перекрёстные whitelists.** Пользователь может быть в whitelist одного чата и отсутствовать в другом; убедиться, что проверки выполняются относительно целевого чата.
- **Различия в политиках.** При несовместимых режимах (например, один чат `auto`, другой `manual`) важно корректно переключать стратегию без утечек глобальных настроек.
- **Хранение данных.** При экспорте датасета `data/messages.csv` необходимо сохранять `chat_id`, чтобы обучающие выборки отражали источник.
- **Синхронизация артефактов.** Если пороги различаются, обучающие артефакты остаются общими; при сильном разнородном трафике может потребоваться сегментация моделей по чатам.

---

## 5. Параметры `.env` для мультичатовой архитектуры

| Переменная | Назначение | Состояние |
|------------|------------|-----------|
| `BOT_TOKEN` | Токен бота. | Без изменений. |
| `DEFAULT_POLICY_MODE` | Значение по умолчанию, если чат не описан в конфиге. | Новый параметр (опционально). |
| `CHAT_CONFIG_PATH` | Путь к YAML/JSON конфигурации чатов. | Новый параметр. |
| `MISTRAL_API_KEY`, `OLLAMA_*`, `EMBEDDING_*` | Провайдеры эмбеддингов — общие для всех чатов. | Без изменений. |
| `MODERATOR_CHAT_ID` | ID служебного чата для уведомлений (например, глобальные алерты). | Может остаться, но карточки для конкретных чатов отправляются в их чаты. |
| `GLOBAL_WHITELIST_USER_IDS` | Пользователи с доступом ко всем чатам. | Новый параметр (опционально). |
| `LOG_LEVEL`, `DETAILED_DEBUG_INFO` | Глобальные настройки логирования и диагностик. | Без изменений. |

Рекомендация: минимизировать количество параметров в `.env`, переместив чатовые настройки в структурированный конфигурационный файл.

---

## 6. План перехода

1. **Подготовка инфраструктуры**
   - Обновить репозиторий, внедрить менеджер конфигураций и расширения `PolicyEngine`.
   - Создать и заполнить `config/chat_config.yaml` со списком целевых чатов.
   - Настроить новые переменные окружения (`CHAT_CONFIG_PATH`, `DEFAULT_POLICY_MODE`).

2. **Миграция данных**
   - Добавить колонку `chat_id` в `data/messages.csv`, `storage` и связанные структуры.
   - Проставить текущее значение чата для существующих записей.

3. **Тестирование**
   - Запустить бот в тестовом окружении с двумя чатами (основной + sandbox).
   - Проверить карточки, команды, логирование.

4. **Запуск в production**
   - Постепенно подключить дополнительные чаты (по одному), наблюдая нагрузки и корректность порогов.
   - Обновить документацию для модераторов (см. `docs/MODERATOR_UX.md`).

5. **Фиксация результатов**
   - Зафиксировать конечную структуру конфигурации.
  - Обновить runbook и инструкции для включения новых чатов.

---

## 7. Мониторинг и проверка

- Вести метрику по каждому чату: количество обработанных сообщений, доля ложных блокировок, среднее время реакции модераторов.
- Добавить в логи идентификатор чата и slug для упрощения анализа.
- После подключения каждого нового чата выполнять ревью конфигурации и порогов через неделю эксплуатации.

---

## 8. Состояние проекта «сейчас»

- Кодовая база поддерживает один чат; конфигурация хранится в `.env`, runtime-параметры общие.
- ML-артефакты и датасеты не разделены по чатам, что упрощает миграцию, но потребует дополнительного атрибутивного поля.
- Модераторские процессы выстроены вокруг одного канала; интерфейс бота готов к расширению (карточки поддерживают дополнительные поля).
